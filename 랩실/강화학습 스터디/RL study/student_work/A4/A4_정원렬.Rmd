---
title: "A4_python_Jeong,wonryeol"
author: "Jeong, wonryeol"
date: "1/3/2021"
output:
  pdf_document: default
  html_document: default
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(background = '718CBA')
library(reticulate)
py_install("pandas")
py_install("matplotlib")
py_install("scipy")
```

# Implementation _basic p11
```{python}
import numpy as np
import pandas as pd

N = 10**3
x = np.random.uniform(0,1,size = N)*2-1
y = np.random.uniform(0,1,size = N)*2-1

t = np.sqrt(x**2 + y**2)

bind=pd.DataFrame({'x':x,'y':y,'t':t})

print(bind.head(5))

pi_hat=4*sum(t<=1)/N

print(pi_hat)
```


\newpage



# Vectorized programming p12

### From the previous slide

```{python}
import time

beg_time = time.time()
np.random.seed(1234)
N = 10**6
x = np.random.uniform(0,1,N)*2-1
y = np.random.uniform(0,1,N)*2-1
t = np.sqrt(x**2 + y**2)

pi_hat=4*sum(t<=1)/N

end_time = time.time()

print(end_time - beg_time)
```

### What first_timer would write
```{python}
import time

beg_time = time.time()
np.random.seed(1234)
N = 10**6
count = 0 

for i in range(N):
  x_i = np.random.uniform(0,1,1)*2-1
  y_i = np.random.uniform(0,1,1)*2-1
  t_i = np.sqrt(x_i**2 + y_i**2)
  if t_i <=1 :
    count += 1

pi_hat = 4*count/N

pi_hat=4*sum(t<=1)/N


end_time = time.time()

print(end_time - beg_time)
```

\newpage

# Implementation - varying number of trials p13


### Approach with a custom function
```{python}
def pi_simulator(N):
  np.random.seed(1234)
  
  x = np.random.uniform(0,1,N)*2-1
  y = np.random.uniform(0,1,N)*2-1
  t = np.sqrt(x**2 + y**2)
  
  pi_hat=4*sum(t<=1)/N
  return pi_hat
```

```{python}
print(pi_simulator(100))

print(pi_simulator(1000))

print(pi_simulator(10000))

print(pi_simulator(100000))

```

### How many repetition is necessary to get closer?
```{python}
num_trials=10**np.arange(2,8)

outcomes = np.vectorize(pi_simulator)(num_trials)

results = pd.DataFrame({'num_trials': num_trials , 'outcomes' : outcomes})

results

```

### The previous figure was plotted by the following code.


```{python}

import matplotlib.pyplot as plt



plt.scatter(results['num_trials'],results['outcomes'], c='blue')
plt.plot(results['num_trials'],results['outcomes'], c='blue')
plt.axhline(3.14,0,1,color='black',linestyle=':')
plt.xscale('log')
plt.grid(True,axis='both')
plt.xlabel('num_trials')
plt.ylabel('outcomes')
plt.show()
```


\newpage

```{python}
def pi_simulator2(N):
  beg_time = time.time()
  
  np.random.seed(1234)
  
  x = np.random.uniform(0,1,N)*2-1
  y = np.random.uniform(0,1,N)*2-1
  t = np.sqrt(x**2 + y**2)
  
  pi_hat=4*sum(t<=1)/N
  
  end_time = time.time()
  print(N)
  print(end_time - beg_time)
  
  return pi_hat
  
  

outcomes = np.vectorize(pi_simulator2)(num_trials)


```


\newpage

## Repetitive simulation experiments



```{python}
def pi_simulator3(N):
  
  
  #np.random.seed(1234)
  
  x = np.random.uniform(0,1,N)*2-1
  y = np.random.uniform(0,1,N)*2-1
  t = np.sqrt(x**2 + y**2)
  
  pi_hat=4*sum(t<=1)/N
  
  end_time = time.time()
  
  return pi_hat
  
n = 100
N = 1000
np.random.seed(1234)

samples = np.zeros(n)
for i in range(n):
  samples[i] = pi_simulator3(N)

print(samples[:6])




```

\newpage
### Exercise1
### Do the Exercise above with n increased by the factor of ten, and present the confidence interval.  p24

```{python, echo = TRUE}

from scipy.stats import t


n = 100
N = 10000
np.random.seed(1234)

samples = np.zeros(n)
for i in range(n):
  samples[i] = pi_simulator3(N)

print(samples[:6])

X_bar = np.mean(samples)

s = np.sqrt(np.sum(X_bar-samples)**2/(n-1))
t_=t(n-1).ppf(0.975)
lb=X_bar-t_*s/np.sqrt(n)
ub=X_bar+t_*s/np.sqrt(n)
lb
ub



```

\newpage

### Exercise2
### Do the Exercise1 above with n increased by the factor of ten, and present the confidence interval.  p24

```{python, echo = TRUE}


n = 1000
N = 10000
np.random.seed(1234)

samples = np.zeros(n)
for i in range(n):
  samples[i] = pi_simulator3(N)

print(samples[:6])

X_bar = np.mean(samples)

s = np.sqrt(np.sum(X_bar-samples)**2/(n-1))
t_=t(n-1).ppf(0.975)
lb=X_bar-t_*s/np.sqrt(n)
ub=X_bar+t_*s/np.sqrt(n)
lb
ub



```








```



